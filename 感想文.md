# udemy を通した学習の感想

## **前書き**

今回の学習で得た知識は今後も必要になると思うので、感想と共に特に重要に感じた部分を共にまとめていく

## 　　**１　環境構築**

### 1.1Git の特性 　　

```　
     ・バージョン管理を目的としたツール
     ・ワーキングディレクトリ、ステージングエリア、ローカルリポジトリの３つの領域を持つ
```

３つの領域によってバージョン管理を行なっている

### 1.2 Git の初期設定

Git をインストールする

- [Git 公式](https://gitforwindows.org/) リンクからダウンロード
  （mac は最初からインストール済み）

Git の初期設定

```
git config --global user.name     （自分の名前）
git config --global user.email     (github に登録するメールアドレス）
git config --global core.editor "code --wait"　(Vscodeを使う場合)
```

### 1.3 Vscode の設定<

- https://code.visualstudio.com/ リンクから Vscode をインストール

- Vscode をダウンロードしたら、command+shift+p で検索欄を開き code command の Path を通す  
  (講師の滑舌が悪く聞きにくかったのでコメントをみた)

## 　 2 　 **Git を使ってバージョン管理をする**

Git ではワーキングディレクトリー、ステージングエリア、ローカルリポジトリの３つの領域がある。

ここで習ったコマンドは高頻度で使うのでちゃんと覚えておきたいと感じた。原理的な部分も理解を深めていきたい。

- ワーキングディレクトリー
  - 現在作業している場所、常に最新の状態にある
- ステージングエリア
  - ワーキングディレトリーの情報を保存する場所
- ローカルリポジトリー
  - 様々なバージョンが全てここに保存される
  - git の目的とも言えるバージョン管理の核となる部分

<u>各領域にデータを移すコマンド</u>

| command              | fromA to B |
| -------------------- | ---------- |
| git add              | WD→SA      |
| git commit           | SA→LR      |
| git restore          | SA→WD      |
| git restore --staged | LR→SA      |

ここまでを聴き私はステージングエリアの存在意義があまりわからなかったが、講師の発言を引用すると

> １回のコミットにはまとまった一つのロジックごとにやるのが良い  
> ステージングエリアがあることでコミットする候補をためておくことができる

ステージングエリアがないといきなり全ての作業がローカルリポジトリに行くから不便になるのではと推測した。

**その他有用なコマンド一覧**
| command | |
| ---- | ---- |
| touch | ファイルを作成 |
| git status | WD,SA,LR の状態を比較（ちゃんと全部同期してるか） |
| git diff(--staged) | WD,SA を比較（LR,SA を比較）変更内容も見れる |
| git rm(--cached) | WD,SA からファイル削除(SA のみ削除) |
| git mv A→B | A から B に名前を変更 |
| git log | commit の履歴を見れる（多数のオプションがある[参照](https://qiita.com/take4s5i/items/15d8648405f4e7ea3039) |
| git blame | 誰が変更したか確認する |
| git tag | commit にタグをつける |
| git tag -a(name)-m"message" | タグに名前とメッセージをつける |

## **３　ブランチを使って作業する**

今回私が一番理解するのに時間がかかったところがここである.  
後半の３ウェイマージやファストフォワードマージ、スカッシュマージは少し理解が甘いと感じているので、これを通してより深く理解していきたい。

### 3.1 ブランチの作成

ブランチを作成する

```
git branch "name"
```

新しいブランチを作成することで、作ったコミットを使うかどうか選択できる。変な変更をして、元のコードに傷をつけないように、branch を使う。

作成したブランチに移動する

```
git switch "name"
```

作成したブランチに移動した後、コミットをこなうことで  
master ブランチが直接指し示していないコミットを作り出せる  
作成、移動をいっぺんに行うのが

```
git switch -c"name"
```

である

ブランチどうしを比較する

```
git log master..A (Aのブランチではどのような変化があったか)
```

より詳しい比較の時

```
dit diff master..A
```

を用いる

### 3.2 ファストフォワードマージ　

1 のように作成したブランチと master を合体する。  
master と HEAD をマージしたいブランチがさすコミットまで持ってれば良い。<br>

マージを行う

```
git merge "name"
```

マージしてもマージしたブランチは消えないので、

```
git branch -d "name"
```

で削除する

### 3.3 ３ウェイマージ

master,新しく作ったブランチそれぞれに対して新しくコミットをする
その後、

```
  git merge ""name
```

によって統合する

{.warning}注意
: ファストフォワードマージを使うとどちらかの情報が消える

### 3.4 スクアッシュマージ

新しく作ったブランチに幾つかのコミットを行う
その後、

```
  git merge --squash
```

によって統合する

新しく作ったブランチが示すコミットは統合されていないので

```
  git branch -D "name"
```

によってブランチを削除する

### 3.5 リベース

３ウェイマージやスクアッシュマージと違って、履歴を一本化できるというメリットがあると感じた  
(履歴が長くなり、分岐が増えてくると履歴が見づらくなるため)

新しいブランチで何個かコミットを行い、master でもコミットを行う
再度 master から新しいブランチに HEAD を動かした後、

```
git rebase master
git switch master
git merge "ブランチ名"
```

下二つはファストフォワードマージを行なっている

## **4 　 Github**

３章まではローカル環境にのみ注目していたが、github によってチームでバージョン管理をしつつ
開発を進めていける点が非常に興味深いところであった。

### 4.1 GitHub に登録する

[GitHub](https://github.co.jp/)から登録を行う.  
この時、メールアドレスは git config で設定したものを使う

### 4.2 リモートリポジトリからデータをコピーする

リモートリポジトリとは

- ローカルリポジトリの内容を保存する
- ここからチームメンバーはデータを持ってきて作業を行いまたアップロードをする

リモートリポジトリからデータをコピーする

```
 git clone "url"  (urlはリポジトリのcodeボタンから)
```

上のように持ってきた、リモートリポジトリの内容に新しくコミット  
が行われた場合,fetch によって更新する

```
 git fetch
```

このままだと main branch が origin branch のひとつ前のコミットを指しているので

```
git merge origin/main
```

でファストフォワードマージを行う  
上の手順では fetch と merge の２つをしなければならなく、基本はこの２つをいっぺんに行う

```
 git pull
```

が用いられる

### 4.3 リモートリポジトリにデータをアップロードする

ローカルリポジトリにコミットを行い、それをリモートリポジトリ  
にアップする場合次のコマンドによってデータをアップする

```
git push
```

ここは私が苦戦したところでもある。初めて push を行うとき  
 パスワードを入力する必要があると言われるが 2023 年 2 月現在パスワードは必要ない  
 代わりにアクセストークンが必要なので
https://qiita.com/mkato1013/items/86040c5e0317951cfaef を参照して作った

git push では tag がアップされないので
`   git push origin "tag名"`
でアップする。消すときは
`   git push origin --delete "tag名"`

### 4.4 Github flow

かなり工程が多かったので、少し理解に苦しいんだところでもある。  
しかし、チームで開発を行なっていく上で、main に傷をつけず進めいていく方法として費用に良いものだと案じた。

新しくブランチを作って作業した後、リモート追跡ブランチを作りながら push したいので

```
git push -u origin "ブランチ名"
```

このように push した内容を精査するために git pull request をする  
他のチームメンバーの承認を受けた後、Merge pull request によって  
リモートリポジトで追加したブランチと Merge する

HEAD を main に切り替えた後 pull を行う  
この時リモート追跡ブランチも一緒に pull されるので

```
git hub prune origin
```

によって削除する  
最後に必要無くなったブランチを削除する

## 5 　コミットの履歴を変更する

### 5.1 git reset

git reset はコミットの履歴を変更する時に用いるコマンドである

```
git reset HEAD~(何個前のコミットか)
```

- git reset のオプション
  - `       git reset --soft HEAD~x`ローカルリポジトリ内のヘッドを x 個前に移す
  - `       git reset --mixed HEAD~x` ローカルリポジトリ内の  
    ヘッドを x 個前にずらし、ステージングエリアも合わせる
  - `       git reset --hard HEAD~x` ローカルリポジトリ内の  
    ヘッドを x 個前にずらした後、ステージングエリア、ワーキングエリアも合わせる

### 5.2 git revert

push したコミットを消すのはダメなので、前のコミットを取り消すというコミットを追加する　
`  git revert HEAD~x
 `
x 個前のコミットを消す

### 5.3 コミットの修正

最新のコミットを修正する場合、追加で修正を加えた後

```
　git commit --amend
```

過去のコミットを修正する場合

```
git rebase --i (コミットID)
```

ここでコミット ID は修正したいコミットのひとつ前  
コミットを修正した後、rebase を抜けたいのなら

```
  git rebase --abort
```

続けるのならば

```
  git rebase --continue
```

### 5.4 コミットの並び替え、統合

過去のコミットの順番を並び替えたい場合は

```
git rebase -i
```

この後、Vscode でコミットを並び替えれば良い

過去のコミットの統合を行いたい場合は

```
git rebase -i
```

この後、Vscode で pick と表記されている部分を squash に変更する

## 6 感想

今回の学習を通してみて、様々苦労することはあったが、基本的にはスムーズに学習を進めることができたと思う  
つまずくところがあれば、外部サイトをあたり解決法を見つける方法をとったことが特に良かったと思う。
